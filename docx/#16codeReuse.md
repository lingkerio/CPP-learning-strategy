# 代码重用

## has-a关系

### 包含(组合，层次化)

包含对象成员的类

1. 将对象成员设置为私有，则类不继承接口，类内成员函数可以使用对象成员的公有接口，类外只能通过类的公有接口访问对象成员
2. 一般构造函数使用成员初始化列表初始化对象成员，初始化列表使用对象成员名而不是类名，如果不使用初始化列表，则自动调用默认构造函数，初始化顺序为被声明的数据

### 私有继承

使用继承并且用private修饰，不过private是默认的，因此可以省略不写

1. 基类的公有成员和保护成员都变为子类的私有成员
2. 初始化基类组件：使用初始化列表，初始化列表使用类名
3. 访问基类的方法：在子类的公有方法中，使用类名和作用域解析运算符来调用
4. 访问基类对象：使用强制类型转换，将子类强制转换为基类类型来访问
5. 访问基类友元函数：将子类对象强制类型转换为基类来正确匹配基类友元函数，如果是重定义<<这一类函数体中还要使用的函数，在函数体中即便是公有继承也要强制类型转换以防止递归调用
6. 私有继承中，基类指针或引用只能指向强制类型转换后的子类对象

### 保护继承

列出基类用protected修饰

1. 基类的公有成员和保护成员都将成为子类的保护成员
2. 与私有继承不同的是：第三代类还可以使用基类的公有接口，而私有继承不行
3. 公有继承和保护继承可以使用隐式向上转换，而私有继承不可以

### 使用建议

1. 包含更简单易用，通常优先使用包含
2. 私有继承和保护继承只能使用一个类的一个对象作为成员，但有更多的特性：
   1. 类包含保护成员，在派生类中可用，但如果被包含到其他类则将不可直接使用
   2. 使用继承可以重新定义虚函数，但包含不可以，重新定义的虚函数只能在类中使用，而不是公有的
   3. 保护继承对内容的封装不如私有继承严密，但更易用

## 多重继承(multiple inheritance)

在使用MI时每一个基类都要用特定标识符表明，不标明则默认private

### 虚基类

为了防止子类从多个父类继承同一个类的多个实例，引入虚基类。如若类A是类B和C的基类，则当从B和C派生出类D时，类D将包含两个类A组件

1. 在派生类B和类C时使用virtual修饰类A，则可让类D只有类A的一个实例，实际上是因为类B和类C共用了同一个类A的实例
2. 构造函数：如果不希望自动调用类A的默认构造函数，则需要在类D的构造函数的初始化列表显式使用类A的构造函数

### 调用继承的方法

如果多个基类有同名方法，子类要调用的话，为了避免二义性，可以使用作用域解析运算符来指明调用的哪个版本的方法，但更好的方法是重定义子类版本的方法，在方法中调用基类的方法

为了防止子类方法访问基类数据进行不必要的多次访问，可以设计模块化方法，在子类组合各个模块

1. 将各个模块设置为protected
2. 也可以将数据组件都设置为protected

### MI中的常见问题

#### 混合使用虚基类和非虚基类

此时基类对象，使用了虚基类的话提供共有的一个，未使用的类各提供一个

#### 虚基类和支配

若没有用类名限定方法名，若某个版本方法名称优先于别的方法，则不会引起二义性，派生类中的名称优先于直接或间接基类的名称

## 类模板

### 定义类模板

template \<typename Type>
class className
{
    ...
};

### 非类型参数

模板头中可以含有带类型的参数，必须是常量表达式，只能是整型、枚举、引用或指针，具体化模板后这个参数像Marco一样生效

### 模板多功能性

#### 模板使用模板

模板A可以用于模板B实现，模板B也可以用于模板A的类型参数以实现模板A

#### 递归使用模板

例如递归使用array模板实现多维数组，维度的顺序与对应的多维数组相反

#### 使用多个类型参数

模板可以有多个类型参数

#### 默认类型模板参数

可以为类型参数提供默认值，如使用模板省略这个参数，编译器将自动使用默认值，这只适用于类模板，不可用于函数模板，为非类型参数提供默认值是通用的

### 模板的具体化

1. 隐式实例化：声明对象，指出所需类型，编译器根据模板生成具体定义
2. 显式实例化：使用==template==关键字，并指出所需类型来声明类，则即使没有创建类对象，也将生成对应类定义
3. 显式具体化：为特定类型提供定义，\<template <> class className\<specialized-type-name> {...};>
4. 部分具体化：
   1. 可以给类型参数的一部分指定具体类型然后单独提供定义，如全部提供则成为了显式具体化
   2. 若有多个模板可供选择，编译器会选择具体化程度最高的模板
   3. 可以为指针提供特殊版本来部分具体化现有模板，这样的话对于指针类型其具体化程度更高
   4. 可以把一个类型参数设置为另一个类型参数的值或者指针

### 成员模板

模板可用作结构、类或者模板类的成员

可以在模板中声明模板方法，在模板外面定义它们,这样定义的话，模板需要嵌套使用，而不是以多个参数呈现

```cpp
template <typename T>
class beta {
public:
    template <typename V>
    V test(T a);
};

template <typename T>
    template <typename V>
        V test(T a){
...
}
```

### 将模板用作参数

模板可以包含类型参数和非类型参数，还可以包含本身就是模板的参数，这是为了实现STL，可以混合使用模板参数和常规参数

### 模板类和友元

模板的友元分3类：

1. 非模板友元
   这一类友元没有模板头，但是参数可以是模板。若参数不含有模板，即为一般的友元函数；否则，一般需要给以模板作为参数的友元提供显式具体化
2. 约束模板友元，友元的类型取决于类被实例化时的类型
   1. 在类定义的前面声明每个函数模板
   2. 在类中再次将模板声明为友元，这些语句根据类模板的参数的类型声明具体化，如果可以根据参数类型推断模板参数类型则<>中可为空，若函数无参数，为了指明使用的函数，需要使用\<Type>来指明
3. 非约束模板友元，及有缘的所有具体化都是类的每一个具体化的友元
   1. 在类内部声明模板
   2. 这种模板可以访问这个类所有实例的数据，需要指明访问的数据

### using

#### using改变重新定义访问权限

在三种权限部分使用会获得对应的权限：using class::function/data;只能使用成员名，没有圆括号、函数特征标、返回类型

#### 模板别名

template\<typename T>
    using arrtype = std::array<T, 12>;
    arrtype\<int> days;//equal to std::array<int, 12>
C++允许将using用于非模板:example=>{
    typedef const char *pc1;
using pc2 = const char*;
    typedef const int *[*pa1](10);
using pa2 = const int*[*](10);
}
