# 公有继承

> class subclass : baseclass {...};

[TOC]

## 预备知识

### protected访问权限符

> 使用protected修饰的成员被称为受保护成员，基类的受保护成员对于派生类来说类似于公有成员，可以直接访问，对于非派生类而言，受保护成员类似于私有成员，不可以直接访问。安全性不如私有成员，但对于 编码更便捷。

### 函数隐藏

> 对于派生类来说，派生类中的函数将会隐藏基类中的同名函数，因此产生了经验性规则：
> 如果需要在派生类重新定义基类的函数
>
> 1. 为每一个同名函数都定义派生类的新版本，不需要新定义的函数，可以在新版本中表现为调用基类版本函数
> 2. 可以定义与基类版本特征标不同的新版本函数

### 虚函数

> 1. 指向基类的指针或是引用可以指向派生类，这是“is a”的继承思想
> 2. 使用关键字==virtual==声明，基类中用virtual声明的函数，在派生类中的同名函数会自动成为虚函数
> 3. 当调用虚函数的对象是以指针或者对象的形式时，调用虚函数的基类版本还是派生类版本取决于指针或引用指向的具体对象的类型，而如果是非虚函数，则取决于指针或引用的类型

## 公有继承的基本规则

> 1. 派生类自动继承基类所有数据成员和大部分成员方法，除构造函数，析构函数，赋值运算符外
> 2. 派生类可以直接访问来自基类的公有成员和受保护成员，可以通过基类的公有方法来访问基类的私有成员

## 派生类需要自定义的成员

### 构造函数

> 派生类的构造函数可以使用成员初始化列表来调用基类构造函数，如果不这样调用，程序会默认调用基类的默认构造函数

### 析构函数

> 派生类应当有自己的析构函数，最好将基类的析构函数声明为虚函数
> 调用析构函数的顺序应该为沿着继承链，先调用派生类析构函数，再调用相邻基类的析构函数

### 赋值运算符

> 如果派生类没有使用动态内存分配，则不需要特别定义自己的赋值运算符
> 如果派生类使用了动态内存分配，则需要定义自己的赋值运算符实现深拷贝

## 抽象基类(abc)

> 当需要抽象出一组类的共同特点，则可以使用abc
> abc的声明需要abc中至少有一个纯虚函数，虚函数声明的结尾加上 = 0，则该函数成为纯虚函数
> abc类不可以创建相应对象，其实现代码也不需要包含纯虚函数的实现代码，纯虚函数不需要实现代码，只是提供一个公共接口
> 具体派生类必须覆盖abc类中的纯虚函数

## 继承与动态内存分配

### 派生类不使用动态内存分配

> 派生类不使用动态内存分配的话，就不需要新定义显式析构函数，复制构造函数，赋值运算符

### 派生类使用动态内存分配

> 派生类需要自定义显式析构函数，复制构造函数，赋值运算符

#### 显式析构函数

> 程序调用派生类的析构函数时，会自动调用基类的显式析构函数，以此清除派生类对象成员中的基类部分
> 派生类显式析构函数只需要负责自定义的新数据成员的清理即可

#### 复制构造函数

> 通过成员初始化列表，在派生类的复制构造函数中调用基类的复制构造函数，如不使用，则默认调用基类的默认构造函数
> 自定义复制构造函数体中只需要负责派生类数据成员的深拷贝

#### 派生类赋值运算符

> 派生类赋值运算符需要显式调用基类的赋值运算符，而不可以直接用赋值运算符完成对基类数据的拷贝，否则会形成递归定义

### 派生类调用基类的友元

> 如果派生类需要调用基类的友元函数，由于友元函数不是成员函数，因此无法用作用域解析符来指明使用哪个版本的友元函数
> 解决方案是使用强制类型转换，传递实参时，将实参强制类型转换转换为基类类型
> 使用dynamic_cast<>强制类型转换运算符是更好的选择
