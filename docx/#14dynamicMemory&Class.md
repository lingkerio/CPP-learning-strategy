# 动态内存分配和类
>
> new 和 delete 对构造函数和析构函数的设计的影响和运算符的重载
>
## 动态内存和类

### 静态类成员
>
> 在类声明中被声明，在包含类方法的文件中初始化，初始化使用作用域运算符来指出静态类成员所在的类。只有const或者枚举型静态类成员才可以在类声明中初始化。
>
### C++成员函数问题
>
>1. 默认构造函数
>2. 默认析构函数
>3. 复制构造函数
>4. 赋值运算符
>5. 地址运算符
>
#### 复制构造函数
>
>==用于初始化过程，包括按值传递参数==
>函数原型为className(const ClassName &);
>
##### 复制构造函数调用时间
>
>1. 函数按值传递对象时
>2. 函数返回对象时
>3. 编译器生成临时对象时（如执行多个对象的加法，生成临时对象保存中间结果）
>按值传递对象将调用复制构造函数，因此应该按引用传递对象，以减少开销
>
##### 复制构造函数具体功能
>
>1. 默认复制构造函数浅复制非静态成员给临时对象，如果有应该在新对象创建时发生变化的静态成员变量，应该提供显式复制构造函数处理
>2. 如果类中包含使用new初始化的指针成员，应该提供显式复制构造函数来深度复制（即复制指针指向的数据）
>
#### 赋值运算符
>
>自动重载的赋值运算符原型为 ClassName & ClassName::operator=(const Class那么&);
>
##### 赋值运算符调用时间
>
>1. 将对象赋给另一个已经有的对象（即非初始化赋值）
>2. 初始化时，根据具体实现决定调用赋值运算符还是复制构造函数
>
##### 赋值运算符具体功能
>
>1. 隐式实现为浅复制每个非静态成员
>2. 如果类中包含使用new初始化的指针成员，应该提供显式复制构造函数来深度复制（即复制指向的数据）
>
##### 具体解决方案
>
>1. 首先检查自我复制，如相同则直接返回*this，不同则进入下一步
>2. delete原先通过new得到的指针成员
>3. 为指针成员分配（new）新的内存存储所要的数据
>4. 返回*this
>
```cpp
c_name & c_name::operator=(const c_name & cn)
{
    if (this == &cn)
        return *this;
    delete [] c_pointer;
    c_pointer = new type_name [size];
    ...
    return *this;
} 
```

## 构造函数中使用new的注意事项
>
>1. 构造函数中使用了new，析构函数必须使用delete
>2. new和delete必须互相兼容，new对应delete，new[]对应delete[]
>3. 如果有多个构造函数必须以相同的方式使用delete，因为析构函数不可以重载，所以析构函数只会有一种使用delete的方法，必须对应。
>4. 如果有的构造函数使用了new而有的构造函数没有使用，则没有使用的构造函数应该将对应的指针成员设置为nullptr或者NULL或者0（最推荐nullptr）
>
## 返回对象的说明

### 返回指向const对象的引用
>
>如果函数返回（通过调用对象的方法或将对象作为参数）传递给它的对象，则使用这种方案。
>
### 返回指向非const对象的引用

>重载赋值运算符以及重载与cout一起使用的<<运算符时使用这种方案。

### 返回对象

> 被返回的对象是被调用函数中的局部变量，则采用这种方案。

### 返回const对象

> 避免一些可能因程序员的粗心带来的语法错误时使用这种方案，如重载+运算符。

## 指针、对象、内存

### 调用析构函数的时期

> 1. 执行完动态变量对象所在的程序块时
> 2. 程序结束时对静态变量对象调用析构函数
> 3. new创建的对象仅当显式调用delete删除对象时调用其析构函数

### 指针和对象

> 1. 使用常规表示法来声明指向对象的指针
> 2. 可以将指针初始化为指向已有的对象
> 3. 可以用new来初始化指针，这将创造一个新的对象，将调用相应的类构造函数初始化新创建的对象
> 4. 可以使用->运算符通过指针访问类方法
> 5. 可以对对象指针应用解除引用运算符（*）来获得对象

### 定位new运算符

> 1. 程序员为了使用一块缓冲区内存单元借助定位new运算符给多个对象分配内存的话，提供给new运算符的地址就需要不同，而且要确保这多个对象所在的内存不重叠
> 2. 为了对使用定位new运算符创建的对象调用析构函数，只有一种办法，显式调用析构函数，这也是唯一需要显式调用析构函数的情况。
> 晚创建的对象可能依赖于早创建的对象，因此应该以与创建顺序相反的顺序进行删除。仅当所有对象都被销毁后，才能调用delete释放这一整块缓冲区内存（仅当这块缓冲区内存也是由new运算符分配才可释放）。

## 一些C++特性

### 嵌套结构和类

> 在类中声明的结构、枚举、类被称为嵌套在类中，作用域为整个类。这种声明不会创建数据对象，只是指定了可以在类中使用的类型。
> 如果声明在类的私有部分进行，则只能在这个类使用被声明的类型，如声明在公有部分进行，则可以在类的外部通过作用域解析运算符使用被声明的类型。

### 成员初始化列表

> 前面带冒号，位于参数列表右括号之后，函数体左括号之前。
> 被声明为引用的类成员和const非静态成员的初始化只能以这种方式进行。

#### 成员初始化列表要点

> 1. 这种格式只能用于构造函数
> 2. 必须用这种格式初始化非静态const数据成员（C++11以前）
> 3. 必须用这种格式来初始化引用数据成员
> 4. 这种格式初始化的顺序与它们出现在类声明中的顺序相同
> 5. 这种格式可以使用常量初始化也可以使用构造函数的参数初始化

### C++11的类内初始化

> 可以直接在类内初始化const非静态成员
> 调用带有成员初始化列表的构造函数可以覆盖这种默认初始值

### 深度复制的预先准备

> 一个类很有必要提供深度复制的复制构造函数和赋值运算符函数，即便还没有使用它们的迹象，这种情况下可以将这两种函数设置为私有函数，起到限制它们使用的效果

### 设置随机数函数的取值范围

> std::rand() * x / RAND_MAX 这条语句生成一个大小区间为[1,x](x >= 1) 或者[0,x](0 < x < 1)的随机数，RAND_MAX定义在cstdlib头文件中，为rand()函数可以产生的最大值。
