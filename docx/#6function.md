# 数组作为函数的参数
[TOC]
## 一维数组作为函数的参数

1. 将数组的第一个元素的地址以及数组的大小传递给函数
2. 由此可见函数并不是操作数组的副本，而是直接操作数组
3. 因此，如果函数不需要对数组进行数据改动，那么传递数组首元素的地址时可以加上const限定符
4. 由于这种传递参数并不是真正传递数组，因此可以对函数有所**_欺骗_**，即将数组里实际需要访问的部分拿出来作为一个小的数组传递给函数
```cpp
int sum__arr(int arr[], int n)
```

5. 使用数组区间的函数，传递两个指针，从第一个指针访问到第二个指针的前一块区域，也就是说第二个指针为所访问的最后一块内存的后一个（也可为最后一块指针，具体看自己怎样实现）
```cpp
int sum_arr(const int* begin,const int* end)
{
    const int* pt;
    int total = 0;

    for (pt = begin; pt != end; pt++)
        {
            total += *pt;
        }
    return total;
}
```
## 二维数组作为函数的参数

1. 函数原型应该提供数组列数，以及单独提供数组行数可以实现更精确的控制，同理可以单独提供想要访问的列数信息（这种额外提供的行数和列数都不是必须的）
```cpp
//第一种
int sum(int (*arr)[4], int size)
//第二种，可读性更高
int sum(int arr[][4], int size)
```

2. 二维变长数组作为参数被提供
```cpp
//指针数组
int arr(int* a[])//可以使用下标访问，精确访问参见上述
{
    //一维数组作为指针数组的元素
}
//二级指针
int arr(int **a)//main函数中传入的实参必须是指针数组
{
    std::cout << *(*(a+1)) << " " << *((*a)) << std::endl;
}
//代码可读性不如第一种方法
```
# C-风格字符串与函数
## C-风格字符串作为参数传递给函数

1. 如果是使用字符串字面量的地址给一个char指针赋值，要注意此时这个char指针实际上是**_const char*_**,那么这个指针不可以被传给会修改字符串内容的函数
2. 把C-风格字符串作为参数的函数，如果不对字符串作出修改，那么应该将形参声明为const，以防止错误地修改了字符串
3. 函数遍历C-字符串的标准方式：
```cpp
while (*str)
{
    statements
	str++;
}//当指针遍历到空字符结束循环
```
### 返回C-风格字符串的函数

1. 实际返回的是这个字符串第一个字符的地址
2. 在函数内部通过new操作符得到的存储空间，在返回给函数外的变量后，在不需要的时候要记得delete这一块内存
# 函数和结构
## 传递和返回结构
### 按值传递

1. 像处理基本数据类型一样处理结构
```cpp
struct lingkerio
{
	unsigned int age;
	char* name;
	int gender;
}

lingkerio change_ins(lingkerio past,unsigned int age, const char* name, int gender)
{
    past.age = age;
    past.name = name;
    past.gender = gender;
    return past;
}
```
### 按地址传递

1. 传递结构的地址给函数，同时也可以由函数返回一个结构的地址
2. 节省了时间和空间
3. 访问成员使用间接成员运算符**_->_**
4. 确定不对传入的结构进行修改的话应该在形参声明加上const
# 函数和对象

1. 可以将对象当成基本数据类型那样在函数的传参，返回方面处理他们
# 递归

