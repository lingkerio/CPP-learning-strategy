# 友元、异常、其他

## 友元

### 友元类

当类A与B没有is a关系，也互相没有has a关系，就应该思考是否是友元。此下，认为B是A的友元类。

友元声明可以位于公有、私有或保护部分，其所在的位置无关紧要。

### 友元成员函数

#### 前向声明

如果使得B成为A的友元类，则不需要前向声明；如果不选择让B成为A的友元类而只是让B中的特定函数成为A的友元函数：

若B含有一个函数是A的友元函数，由于在A中声明时要用作用域解析运算符声明该函数属于B，因此B应该定义在A前。但B中的友元函数要求知道A的定义，因此需要A定义在B前。为了摆脱这种循环依赖，需要使用前向声明。

```cpp
class A;
class B {...};
class A {...};
```

即先声明存在一个类A

若B中的函数还会调用A的接口或者是数据成员，则需要只是在B中声明这个函数，在定义了A之后再给出这些函数的定义。即使需要这些函数是内联函数，也可以通过inline关键字解决

### 其他友元关系

使得A和B互为友元类：

```cpp
class A {
friend class B;
...
};
class B {
friend class A;
...
};
```

对于使用B对象的A方法，其原型可以在B声明之前声明，但必须在B声明之后定义。但对于使用A对象的B方法，可以在B声明中直接定义。

### 共同的友元

可以将一个函数作为两个类的友元，这样做的时候需要注意函数应该在什么区域被声明，在什么区域被定义，需要注意使用前向声明

## 嵌套类

在另一个类中声明的类被称为嵌套类（nested class）

包含类的成员函数可以创建和使用被嵌套类的对象；而仅仅当嵌套类的声明位于公有部分才可以在包含类外通过作用域解析符使用

### 嵌套类和访问权限

#### 作用域

|声明位置|包含它的类是否可以使用它|派生类是否可以使用它|在外部是否可以使用|
|:---:|:---:|:---:|:---:|
|私有部分|是|否|否|
|保护部分|是|是|否|
|公有部分|是|是|是，通过类限定符来使用|

#### 访问控制

类声明的位置决定了类的作用域与可见性，访问控制规则决定访问控制权限

### 模板中的嵌套

当类作为模板时，内部的嵌套类不会带来问题，嵌套类也可以使用模板的类型参数

## 异常

需要使用一些方法来处理异常

### 调用abort()

位于头文件stdlib.h或者cstdlib，调用直接中断程序

### 返回错误码

使用指针或者引用参数将值返回给调用程序，通过函数返回值指出成功还是失败。对于内置类型，一般使用指针。

可以使用全局变量来代替指针或引用的使用，但是要保证全局变量没有用于其他目的。（传统C语言数学库使用这种方法，使用的全局变量名为errno）

### 异常机制

异常机制提供了将控制权从程序一个部分传递到另一部分的途径。

组成部分分为3个：

1. 引发异常
2. 使用处理程序捕获异常
3. 使用try块

三个关键字：catch，try，throw

try块标识其中特定的异常可能被激活的代码块，后面跟一个或多个catch块。try后跟一个代码块表明需要注意这些代码引发的异常。

catch表示捕获异常，后跟括号中的类型声明，指出了异常处理程序要响应的异常类型，再跟着一个代码块，指出要采取的措施。catch关键字和异常类型声明构成了catch块的标签。

throw语句是一个跳转，表示引发异常，紧随其后的值指出了异常的特征。

```cpp
try
{
   call function A ...
}
catch (Typename name)
{
    exception process action
}

return_value A(parameter_list)
{
    ...
    throw value;
    ...
}
```

如上，当调用A函数，触发了throw语句，则引发了异常value，value的数据类型即为异常类型，将会与类型匹配的catch块匹配，执行catch块内的异常处理程序

### 将对象用作异常类型

这样做的优点有：

1. 可以使用不同的异常类型来区分不同的函数在不同情况下引发的异常
2. 对象可以携带信息，这有助于程序员找到引发异常的原因

### 异常规范和C++11

#### 已经被摈弃的异常规范

在函数原型和函数定义中，直接在函数的参数列表后，添加一个throw语句，可以包含参数也可以不包含。

在使用这个特性时，由于函数的嵌套调用导致的异常可能无法被检查到或者是库文件的版本差异就有可能引发异常导致其被社区摈弃。

C++17已经删除了这个特性。

#### noexcept关键字

这是C++11新增的一种异常规范。

这是C++11新增的关键字，用于指示函数不会引发异常，直接用于函数的参数列表后。

noexcept与noexcept(true)等价，而throw()是noexcept(true)的别名，在C++14模式下，如果函数确实引发异常，throw()会带来未定义行为(UB)，因此推荐使用noexcept或者是noexcept(true).

这个关键字的使用可以帮助编译器优化代码，同时也有人建议至少大多数情况下不要使用。

noexcept()运算符，用于检查操作数是否会引发异常。

### 栈解退(unwinding the stack)

try块如果调用了函数A，而函数A调用了引发异常的函数B，则程序流程将从引发异常的函数跳到包含try块和异常处理程序的函数。而这涉及到栈解退。

函数的嵌套调用中如有函数引发异常，则会不断释放栈，直到找到一个位于try块中的返回地址，然后，程序控制权来到try块末尾的catch块。

并且需要这个try块跟着的catch块能够正确捕获异常，否则将继续栈解退。

一个重要特性是，栈解退的过程，函数的嵌套调用产生的自动变量也会释放。

在引发某个异常后，当控制权到了catch块中，如果遇到不带任何参数的throw语句，则会重新引发这个异常。

### 其他异常特性

引发异常时，总是对异常创建一个临时拷贝，即使异常规范和catch块指定的是引用。

这是因为，当异常被引发，如果异常是一个该引发异常的函数创建的自动变量，则当栈解退后，该变量就不复存在。

而之所以仍然使用引用而不是值传递的原因是：基类引用可以指向派生类对象。

如此一来，catch块异常类型是基类引用的话将能够捕获任何基类或派生类对象异常。

而如果有一个异常类继承层次结构，将catch块以与它们捕获的异常类型在层次结构中的顺序的相反方向排列，这样能够在如何处理异常上留有余地。

用省略号表示异常类型的catch块将能够捕获任何种类异常，可以将这种catch块放在最后，类似于switch语句的default。

可以创建捕获对象而不是引用的处理程序，如在catch中使用基类对象，则被捕获的对象的派生特性将会被剥离，如有使用该对象的虚方法，也将会使用基类版本。

### exception类

exception头文件定义了exception类，可以把它用作其他异常类的基类，也可以引发exception异常。其含有名为what()的虚函数成员，返回一个字符串，具体字符串随实现而异，可以在exception类的派生类中重新定义。

#### stdexcept异常类

头文件stdexcept定义了一些异常类，它们的构造函数接受一个string对象引用作为参数，为了提供what方法返回的字符数据：

1. logic_error类：派生自exception类，作为logic_error类系列的基类
   1. domain_error类：函数定义域异常类
   2. invalid_error类：无效参数异常类
   3. length_error类：长度不足异常类
   4. out_of_bounds类：索引越界异常类
2. runtime_error类：派生自exception类，作为runtime_error类系列的基类
   1. range_error类：函数值域异常类，若既没有上溢或下溢，但值不在函数允许范围内，则可以使用
   2. overflow_error类：浮点数计算上溢异常类
   3. underflow_error类：计算下溢异常类

这两个系列的类帮助能够分别处理每个异常，也可以通过继承关系统一处理异常

如果有需要，也可以从logic_error或者runtime_error类派生自定义的异常类

#### bad_alloc异常和new

new头文件定义了bad_error异常类，new导致的内存分配问题将会引发bad_alloc异常，可以用该类的what方法显示异常消息

#### 空指针和new

对new使用(std::nothrow)标记将能够调用导致内存分配问题时返回空指针的new

### 异常、类和继承

首先，可以像标准C++库一样，从一个异常类派生出另一个；其次，可以在类定义中嵌套异常类声明来组合异常；最后，这种嵌套声明本身可以被继承，还可以用作基类。

### 异常何时会迷失方向

异常被引发后会出问题的两种情况：

1. 在带异常规范的函数中引发，则必须与规范列表中的某种异常匹配，否则称为意外异常。默认情况下，这将会导致程序终止。
2. 如果异常不是在函数中引发的（或者函数没有异常规范），则必须捕获它，否则称为未捕获异常，默认情况下，这将会导致程序终止。

可以修改程序对意外异常和未捕获异常的反应：

未捕获异常：当出现未捕获异常，程序将先调用terminate()函数，而该函数默认情况下将调用abort()函数。set_terminate()函数可以控制terminate()调用哪个函数。

```cpp
typedef void (*terminate_handler) ();
terminate_handler set_terminate(terminate_handler f) throw();//在C++14中可能会带来未定义行为，不推荐使用
terminate_handler set_terminate(terminate_handler f) noexcept;//推荐使用
void terminate();//C++98
void terminate() noexcept;//C++11
```

只需要自定义的函数无返回值即可设置为被terminate()调用。

意外异常：如果发生意外异常，程序将先调用unexpected()函数，该函数将会调用terminate()函数，而terminate()函数又将会默认调用abort()函数。set_unexpected()函数可以更改unexpected()函数的行为。

unexpected()函数可以调用terminate()函数、abort()、exit()函数来终止程序，也可以引发异常：

- 新引发的异常与原来的异常规范匹配的话，则程序从那里开始，寻找与新引发异常匹配的catch块，即相当于用自定义异常取代了意外异常。
- 新引发的异常与原来的异常规范不匹配，且异常规范中没有包括std::bad_exception类，则程序将调用terminate()函数。
- 新引发的异常与原来的异常规范不匹配，且异常规范中包含类std::bad_exception类，则不匹配的异常将会被bad_exception异常所取代。

==需要注意，C++17已经删除这种遗产规范，学习这部分是考虑到以前的代码可能使用了异常规范==

### 有关异常的注意事项

- 应该在设计程序时期加入异常处理程序，而不是以后。
- 使用异常会增加程序代码，降低程序的运行速度。
- 异常规范不适用于模板。
- 异常和动态内存分配并非总能协同工作。

类的析构函数在栈解退的特性下，会自动调用。

而一般的动态内存分配，则需要注意delete和new的使用。

为了防止栈解退而导致指向动态分配的内存的指针消失却没有释放相应内存导致的内存泄漏，可以在引发异常时，在同一个函数中捕获该异常，然后释放内存，接着使用无参数的throw语句重新引发异常。

## RTTI（Runtime Type Identification）

### RTTI的用途

明确跟踪或确认继承链中基类指针指向的对象的实际类型。

### RTTI的工作原理

只能将RTTI用于包含虚函数的类层次结构，只有这种类层次结构，才应该将派生对象的地址赋给基类指针。

C++有三个支持RTTI的元素：

1. dynamic_cast运算符：使用一个指向基类的指针来生成一个指向派生类的指针，否则该运算符返回0——空指针
2. typeid运算符：返回一个指出对象的类型的值
3. type_info类：存储了有关特定类型的信息

#### dynamic_cast运算符

`dynamic_cast<Type *>(pt)`

如果pt指向的对象的类型为Type或者是从Type直接或间接派生而来的类型，则表达式返回一个Type类型的指针，否则返回0

也可以将dynamic_cast用于引用，需要包含typeinfo头文件引入bad_cast异常来表示类型转换失败，可以增加一个try—catch块捕获该异常，语法为：

`dynamic_cast<Type &>(rt)`

#### typeid运算符和type_info类

typeid运算符可以接受两种参数：

1. 类名
2. 结果为对象的表达式

typeid运算符返回一个对type_info类的引用，type_info类是在头文件typeinfo中定义的，其重载了==和!=运算符，以便通过这些运算符完成类型比较。

如果typeid运算符接受了一个空指针解引用表达式，将引发bad_typeid异常，也是在typeinfo头文件中定义的，具体实现随厂商而异，包含一个name()成员函数，返回一个随实现而异的字符串：

通常（并非一定）是类的名称。

#### 误用RTTI的例子

如果发现了if-else语句系列使用了typeid，则应该考虑是否应该使用虚函数和dynamic_cast。

## 类型转换运算符

- dynamic_cast
- const_cast
- static_cast
- reinterpret_cast

### dynamic_cast

syntax:`dynamic_cast< type-name > (expression)`

### const_cast

syntax:`const_cast< type-name > (expression)`

该运算符用于改变值的const或volatile特征，除了这两种特征不同，type-name和expression的类型必须相同

修改const值的结果是不确定，编译器可能会禁止修改

### static_cast

syntax:`static_cast< type-name > (expression)`

仅当typename可以被隐式转换为expression的类型，或expression可以被隐式转换为typename所属的类型，上述转换才合法，否则将出错。

可以用这个运算符进行继承链上的类型转换，也可以进行枚举值和整型、或者其他数值类型的转换

### reinterpret_cast

syntax:`reinterpret_cast< type-name > (expression)`

reinterpret_cast用于天生危险、依赖于实现、令人生厌的类型转换操作，一般是不可移植的。

存在一些限制：可以将指针类型转换为足以存储指针表示的整型，但不可以转换为更小的整型或浮点型；不能将函数指针转换为数据指针，反之亦然。

在C++中，普通类型转换也受到限制。
